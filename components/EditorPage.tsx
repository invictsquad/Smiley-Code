import { useState, useEffect, useCallback } from 'react';
import { Project, Message, FileTree, Version, Language } from '../types';
import ChatSidebar from './ChatSidebar';
import PreviewWindow from './PreviewWindow';
import CodeViewerModal from './CodeViewerModal';
import PublishModal from './PublishModal';
import GitHubDeployModal from './GitHubDeployModal';
import AnalysisPanel from './AnalysisPanel';
import { t } from '../lib/i18n';
import { RealDataIntegrator, popularDataSources } from '../lib/realDataIntegration';
import { ProjectNameGenerator } from '../lib/projectNameGenerator';
import { AutoVersioningSystem } from '../lib/autoVersioning';
import { IconLibraryManager } from '../lib/iconLibrary';
import { SmartTypographyManager } from '../lib/smartTypography';
import { DarkModeGenerator } from '../lib/darkModeGenerator';
import { AnimationLibrary } from '../lib/animationLibrary';
import { GradientGenerator } from '../lib/gradientGenerator';

// FIX: The Gemini API client is initialized according to the provided guidelines.
import { GoogleGenerativeAI } from "@google/generative-ai";


// Per guidelines, initialize Gemini API client.
// The API key is expected to be in import.meta.env.GEMINI_API_KEY.
const genAI = new GoogleGenerativeAI(import.meta.env.GEMINI_API_KEY!);

interface EditorPageProps {
    initialProject: Project;
    onSaveAndExit: (updatedProject: Project) => void;
    theme: 'light' | 'dark';
    onThemeChange: (theme: 'light' | 'dark') => void;
    language: Language;
    onLanguageChange: (lang: Language) => void;
    initialPrompt: string | null;
    initialImages: { data: string; mimeType: string; }[] | null;
}

const EditorPage: React.FC<EditorPageProps> = ({
    initialProject,
    onSaveAndExit,
    theme,
    onThemeChange,
    language,
    onLanguageChange,
    initialPrompt,
    initialImages,
}) => {
    const [project, setProject] = useState<Project>(initialProject);
    const [messages, setMessages] = useState<Message[]>([]);
    const [isLoading, setIsLoading] = useState(false);

    // History for Undo/Redo
    const [history, setHistory] = useState<{ fileTree: FileTree }[]>([{ fileTree: initialProject.fileTree }]);
    const [currentHistoryIndex, setCurrentHistoryIndex] = useState(0);

    // Version History
    const [versionHistory, setVersionHistory] = useState<Version[]>([]);

    // UI State
    const [isSidebarVisible, setIsSidebarVisible] = useState(true);
    const [isCodeViewerOpen, setIsCodeViewerOpen] = useState(false);
    const [isPublishModalOpen, setIsPublishModalOpen] = useState(false);
    const [isGitHubModalOpen, setIsGitHubModalOpen] = useState(false);
    const [isAnalysisPanelOpen, setIsAnalysisPanelOpen] = useState(false);

    const updateFileTree = useCallback((newFileTree: FileTree, actionName?: string, aiMessage?: string) => {
        const oldFileTree = project.fileTree;

        console.log('üîÑ updateFileTree called:', {
            actionName,
            oldFileCount: Object.keys(oldFileTree).length,
            newFileCount: Object.keys(newFileTree).length,
            hasIndexHtml: !!newFileTree['index.html'],
            newFiles: Object.keys(newFileTree)
        });

        setProject(p => ({ ...p, fileTree: newFileTree }));

        const newHistory = history.slice(0, currentHistoryIndex + 1);
        newHistory.push({ fileTree: newFileTree });
        setHistory(newHistory);
        setCurrentHistoryIndex(newHistory.length - 1);

        // Sistema de versionamento autom√°tico
        const analysis = AutoVersioningSystem.analyzeChanges(oldFileTree, newFileTree, aiMessage || actionName);

        // Sempre criar vers√£o para mudan√ßas significativas
        if (AutoVersioningSystem.shouldCreateVersion(analysis) || actionName) {
            const autoVersion = AutoVersioningSystem.createAutoVersion(
                oldFileTree,
                newFileTree,
                aiMessage || actionName,
                versionHistory.length + 1
            );

            // Se foi fornecido um actionName manual, usar ele
            if (actionName && !aiMessage) {
                autoVersion.name = actionName;
                autoVersion.metadata = {
                    ...autoVersion.metadata,
                    isAutoGenerated: false
                };
            }

            setVersionHistory(prev => [autoVersion, ...prev]);
        }
    }, [history, currentHistoryIndex, project.fileTree, versionHistory.length]);


    const handleUndo = () => {
        if (currentHistoryIndex > 0) {
            const newIndex = currentHistoryIndex - 1;
            setCurrentHistoryIndex(newIndex);
            setProject(p => ({ ...p, fileTree: history[newIndex].fileTree }));
        }
    };

    const handleRedo = () => {
        if (currentHistoryIndex < history.length - 1) {
            const newIndex = currentHistoryIndex + 1;
            setCurrentHistoryIndex(newIndex);
            setProject(p => ({ ...p, fileTree: history[newIndex].fileTree }));
        }
    };

    const canUndo = currentHistoryIndex > 0;
    const canRedo = currentHistoryIndex < history.length - 1;

    // Set initial message and trigger first generation if there is an initial prompt
    useEffect(() => {
        // Criar vers√£o inicial do projeto
        if (versionHistory.length === 0) {
            const initialVersion: Version = {
                id: 'initial-v0',
                name: 'Projeto criado',
                createdAt: new Date(),
                fileTree: initialProject.fileTree,
                metadata: {
                    changeType: 'creation',
                    severity: 'major',
                    filesChanged: Object.keys(initialProject.fileTree),
                    isAutoGenerated: true
                }
            };
            setVersionHistory([initialVersion]);
        }

        const initialMessage: Message = {
            id: 'init',
            role: 'assistant',
            text: t('editor.initialMessage', language)
        };
        if (initialPrompt) {
            const userMessage: Message = {
                id: 'init-user',
                role: 'user',
                text: initialPrompt,
                images: initialImages || undefined
            };
            setMessages([initialMessage]);
            // We pass the message directly to handleSendMessage instead of setting state first
            // to avoid race conditions and ensure the function has the latest data.
            handleSendMessage(userMessage, false, true);
        } else {
            setMessages([initialMessage]);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    const parseAndApplyFileChanges = (aiResponseText: string, isFirstMessage: boolean) => {
        // Updated regex to be more flexible and handle potential whitespace variations.
        const jsonMatch = aiResponseText.match(/```json\s*([\s\S]*?)\s*```/);
        if (!jsonMatch) {
            // FIX: Corrected typo from `aiResponse-text` to `aiResponseText` to use the function parameter.
            return { text: aiResponseText, plan: undefined, fileChanges: undefined, success: true };
        }

        try {
            let jsonString = jsonMatch[1].trim();

            // Check if JSON is truncated and try to fix common issues
            if (!jsonString.endsWith('}')) {
                console.warn('JSON appears to be truncated, attempting to fix...');

                // Try to find the last complete object structure
                let braceCount = 0;
                let lastValidIndex = -1;

                for (let i = 0; i < jsonString.length; i++) {
                    if (jsonString[i] === '{') braceCount++;
                    if (jsonString[i] === '}') {
                        braceCount--;
                        if (braceCount === 0) {
                            lastValidIndex = i;
                        }
                    }
                }

                if (lastValidIndex > 0) {
                    jsonString = jsonString.substring(0, lastValidIndex + 1);
                    console.log('Truncated JSON fixed, attempting to parse...');
                } else {
                    // If we can't fix it, try to extract at least the message
                    const messageMatch = jsonString.match(/"message"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/);
                    if (messageMatch) {
                        return {
                            text: messageMatch[1].replace(/\\"/g, '"').replace(/\\n/g, '\n'),
                            plan: undefined,
                            fileChanges: undefined,
                            success: true
                        };
                    }
                    throw new Error('JSON is severely malformed and cannot be recovered');
                }
            }

            const parsed = JSON.parse(jsonString);
            const newFileTree = { ...(isFirstMessage ? {} : project.fileTree) };
            let updatedFiles: string[] = [];

            console.log('üìù Processing AI response:', {
                hasFileChanges: !!parsed.file_changes,
                fileChangesType: typeof parsed.file_changes,
                fileChangesKeys: parsed.file_changes ? Object.keys(parsed.file_changes) : []
            });

            if (parsed.file_changes && typeof parsed.file_changes === 'object') {
                for (const [path, content] of Object.entries(parsed.file_changes)) {
                    if (content === null || content === 'DELETE') {
                        delete newFileTree[path];
                        console.log(`üóëÔ∏è Deleted file: ${path}`);
                    } else {
                        newFileTree[path] = content as string;
                        console.log(`üìÑ Added/Updated file: ${path} (${(content as string).length} chars)`);
                    }
                    updatedFiles.push(path);
                }
            }

            console.log('üìÅ Final fileTree:', {
                totalFiles: Object.keys(newFileTree).length,
                hasIndexHtml: !!newFileTree['index.html'],
                indexHtmlLength: newFileTree['index.html'] ? newFileTree['index.html'].length : 0,
                files: Object.keys(newFileTree)
            });

            if (updatedFiles.length > 0) {
                updateFileTree(newFileTree, parsed.message, aiResponseText);
            } else {
                console.warn('‚ö†Ô∏è No files were updated from AI response');
            }

            return {
                text: parsed.message || t('editor.updateSuccess', language),
                plan: parsed.plan,
                fileChanges: updatedFiles.length > 0 ? updatedFiles : undefined,
                success: true
            };
        } catch (error) {
            console.error('Failed to parse AI response JSON:', error);
            console.error('Raw JSON length:', jsonMatch[1].length);
            console.error('Raw JSON preview (first 500 chars):', jsonMatch[1].substring(0, 500));
            console.error('Raw JSON preview (last 500 chars):', jsonMatch[1].substring(Math.max(0, jsonMatch[1].length - 500)));

            // Try to extract file_changes even from malformed JSON
            const fileChangesMatch = jsonMatch[1].match(/"file_changes"\s*:\s*\{([^}]+(?:\{[^}]*\}[^}]*)*)\}/s);
            if (fileChangesMatch) {
                console.log('üîß Attempting to recover file_changes from malformed JSON');
                try {
                    const fileChangesJson = `{"file_changes": {${fileChangesMatch[1]}}}`;
                    const recovered = JSON.parse(fileChangesJson);

                    const newFileTree = { ...(isFirstMessage ? {} : project.fileTree) };
                    let updatedFiles: string[] = [];

                    for (const [path, content] of Object.entries(recovered.file_changes)) {
                        if (content !== null && content !== 'DELETE') {
                            newFileTree[path] = content as string;
                            updatedFiles.push(path);
                        }
                    }

                    if (updatedFiles.length > 0) {
                        updateFileTree(newFileTree, 'Recovered from malformed JSON', aiResponseText);
                        return {
                            text: 'C√≥digo gerado com sucesso (recuperado de JSON malformado)',
                            success: true,
                            fileChanges: updatedFiles
                        };
                    }
                } catch (recoveryError) {
                    console.error('Failed to recover file_changes:', recoveryError);
                }
            }

            // Try to extract just the message for user feedback
            const messageMatch = jsonMatch[1].match(/"message"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/);
            const extractedMessage = messageMatch ?
                messageMatch[1].replace(/\\"/g, '"').replace(/\\n/g, '\n') :
                'Erro ao processar resposta da IA. O JSON retornado est√° malformado.';

            return {
                text: extractedMessage,
                success: false
            };
        }
    };

    // M√©todo auxiliar para detectar tipo de projeto
    const detectProjectType = (prompt: string, fileTree: FileTree): string => {
        const text = prompt.toLowerCase();
        const htmlContent = fileTree['index.html']?.toLowerCase() || '';

        if (text.includes('portfolio') || htmlContent.includes('portfolio')) return 'portfolio';
        if (text.includes('blog') || htmlContent.includes('blog')) return 'blog';
        if (text.includes('ecommerce') || text.includes('shop') || text.includes('store')) return 'ecommerce';
        if (text.includes('dashboard') || text.includes('admin')) return 'dashboard';
        if (text.includes('landing') || text.includes('marketing')) return 'landing';
        if (text.includes('business') || text.includes('corporate')) return 'business';
        if (text.includes('creative') || text.includes('agency')) return 'creative';

        return 'tech'; // default
    };

    const handleSendMessage = async (message: Message, isSeniorMode: boolean, isFirstMessage = false) => {
        if (!import.meta.env.GEMINI_API_KEY) {
            setMessages(prev => [...prev, { id: 'error', role: 'assistant', text: t('editor.apiKeyError', language) }]);
            return;
        }

        setMessages(prev => [...prev, message]);
        setIsLoading(true);

        try {
            const systemInstruction = `You are "Smiley Code", an expert AI web developer specializing in creating beautiful, modern, enterprise-grade web applications using the latest best practices.

**Core Mandate: Create Complete & Functional Applications**
Your primary directive is to build complete, fully functional web applications. Do not create partial or non-working apps. Based on the user's request, the application you generate must include a minimum of five distinct, working features that are directly related to the user's prompt. Every feature must be fully implemented, interactive, and functional. Fulfilling the user's request is your top priority.

**1. Core Technology Stack & Principles:**
- **UI:** You MUST build UI by replicating shadcn/ui components using TailwindCSS utility classes. Project is pre-configured with the latest TailwindCSS.
- **JavaScript:** All JS MUST be modern ES6+ in \`.js\` files with strong JSDoc type annotations.
- **Code Quality:** Write clean, readable, component-based code. Use console logs for debugging.
- **Responsiveness & A11y:** All apps MUST be mobile-first, responsive, and accessible (semantic HTML, ARIA). Every \`index.html\` MUST include \`<meta name="viewport" content="width=device-width, initial-scale=1.0">\`. Use semantic HTML5 elements, proper heading hierarchy, alt attributes for images, and ARIA labels where needed.
- **Performance:** Optimize for fast loading - minify CSS/JS, compress images, use efficient selectors, implement lazy loading for images and content below the fold.
- **SEO:** Include proper meta tags (title, description, keywords), Open Graph tags, structured data when relevant, and semantic HTML structure.
- **Project Structure:** Use a clean folder structure (\`pages/\`, \`styles/\`, \`scripts/\`, \`assets/\`). The main files are \`index.html\`, \`styles/style.css\`, \`scripts/main.js\`. For multi-page apps or user flows, create separate HTML files (e.g., \`pages/about.html\`) and link them together appropriately. For larger projects, you may adopt a feature-based folder structure (e.g., \`features/authentication/\`, \`features/products/\`) for better organization.

**2. AI Reasoning & Interaction:**
- **Code-Awareness:** Before writing any code, you MUST thoroughly analyze the "Current Project Files" provided below to understand the existing structure and logic. Your changes MUST be incremental and compatible with the current code.
- **Clarifying Questions:** If a user's request is ambiguous (e.g., "add a button"), you MUST ask clarifying questions instead of making assumptions. (e.g., "Certainly! What should the button say, where should it be placed, and what should happen when it's clicked?").
- **Debugging Assistant:** If the user provides an error message from the browser console, you MUST analyze the existing code, explain the cause of the error in simple terms, and provide the necessary file changes to fix it.
- **Style & Preference Learning:** Pay close attention to the user's feedback and explicit requests within the current session. If they ask for a specific color, font, or layout style, adopt it for subsequent responses in this session.
- **Continuous Knowledge:** Apply the latest web development trends and UI/UX best practices to ensure the generated applications are modern and high-quality.
- **"Explain This Code":** If a user pastes a code snippet and asks for an explanation, you MUST provide a clear, step-by-step breakdown of what the code does in the 'message' field of your response. In this case, you should not propose any file changes unless explicitly asked.

**3. Design, UX & Interactivity (MOBILE FIRST):**
- **Mobile First Design:** ALWAYS start with mobile design (320px+) and progressively enhance for larger screens. Use mobile-first CSS media queries (@media (min-width: 768px)).
- **Touch-Friendly Interface:** All interactive elements must be at least 44px in size for touch accessibility. Use appropriate spacing between clickable elements.
- **Responsive Typography:** Use fluid typography that scales smoothly across devices. Start with smaller font sizes for mobile and scale up for desktop.
- **Compact Layouts:** Design compact, space-efficient layouts for mobile. Stack elements vertically on small screens and use horizontal layouts only on larger screens.
- **Thumb-Friendly Navigation:** Place primary navigation and actions within easy thumb reach (bottom 2/3 of screen on mobile).
- **Fast Loading:** Optimize for mobile networks with compressed images, minimal JavaScript, and efficient CSS.
- **Modern Animations:** Use subtle animations that don't impact performance on mobile devices. Prefer CSS transforms over layout-changing animations.
- **Smart Typography:** Use system fonts or fast-loading web fonts. Ensure text is readable on small screens with appropriate line height and spacing.
- **Dark Mode Support:** Include mobile-optimized dark mode with proper contrast ratios for outdoor viewing.
- **Accessibility First:** Ensure all interactions work with screen readers and keyboard navigation on mobile devices.
- **Performance Optimization:** Implement lazy loading, optimize images for different screen densities, and minimize bundle size for mobile networks.

**4. Advanced Features & Architecture (When Requested):**
- **Mock Data Generation:** If asked to create examples or lists, you MUST create a \`scripts/mock-data.js\` file, export an array of realistic objects, and then import and use this data in \`scripts/main.js\` to populate the UI.
- **Context-Aware Personalization:** Implement features based on user context. For example, add a script to display a greeting ("Good morning," "Good afternoon") based on the user's local time.
- **Browser API Integration:** Seamlessly integrate with modern browser APIs. Use \`navigator.clipboard\` for "Copy to Clipboard" buttons and \`navigator.onLine\` to create an "Offline" status indicator.
- **Client-Side Routing (SPA):** If asked to "make this a Single Page Application," you MUST implement a simple client-side router in \`scripts/router.js\` using the browser's History API, refactor the main script to load page content dynamically, and update the page's \`<title>\` and meta tags dynamically to reflect the current view.
- **Local Storage Utilities:** If the user needs to persist data, you MUST create a helper file (e.g., \`scripts/storage.js\`) with clear functions (\`saveToStorage\`, \`loadFromStorage\`) to abstract interactions with \`localStorage\`.
- **API Client SDK Generation:** If the user describes their API endpoints (e.g., "I have a GET /users and a POST /users/:id"), you MUST generate an \`scripts/api-client.js\` file containing functions for each endpoint (e.g., \`getUsers()\`, \`updateUser(id, data)\`).
- **PWA Conversion:** If asked to "make this a PWA", you MUST: 1. Create a \`manifest.json\` file. 2. Create a \`sw.js\` (service worker) with a basic offline caching strategy. 3. Add the manifest link to \`index.html\`. 4. Add the service worker registration script to \`scripts/main.js\`.
- **Data Visualization & Charts:** If asked to create a chart, you MUST add a CDN link for a charting library (like \`Chart.js\`) to \`index.html\`, add a \`<canvas>\` element, and then write the JavaScript in \`scripts/main.js\` to initialize the chart.

**5. Performance & Optimization (When Requested):**
- **Critical CSS:** Analyze the HTML/CSS and identify the essential styles for the "above-the-fold" content. You MUST then suggest inlining these critical styles in a \`<style>\` tag in the \`<head>\` of the \`index.html\`.
- **Font Loading Strategy:** Optimize custom font loading by adding \`<link rel="preload" as="font">\` tags to the HTML and ensuring \`font-display: swap;\` is used in the CSS.
- **Unused Code Detection:** If asked, you MUST analyze the JS and CSS files to identify functions, classes, or rules that are defined but never used, and suggest their removal to reduce file size.
- **Refactor to Web Workers:** For computationally expensive tasks (e.g., complex data processing), you MUST be able to refactor the logic by creating a new file (e.g., \`scripts/my-worker.js\`) and moving the heavy lifting there, updating the main script to communicate with the worker.
- **Browser Performance Analysis:** Generate code snippets using the Browser's Performance API (e.g., \`performance.measure()\`) to help the user measure and debug the speed of specific functions.

**6. Deployment & Documentation (When Requested):**
- **Bundler Configuration:** If asked to "set up for Vite," you MUST generate a \`package.json\` with the necessary dev dependencies and a standard \`vite.config.js\` file.
- **User Persona Generation:** If asked to "create user personas," you MUST generate a \`PERSONAS.md\` file detailing different user archetypes to help guide the development process.
- **Automatic README Generation:** If asked to "create a README," you MUST generate a \`README.md\` file that includes the project name, a brief description, and instructions on how to run it.

**7. CRITICAL: Output Format**
You MUST ONLY reply with a single markdown code block containing a valid JSON object. Do NOT add any text or explanation outside of this block.
Your response MUST conform to this exact structure:
\`\`\`json
{
  "message": "I've updated the homepage with a new hero section and restyled the primary button as you requested.",
  "plan": [
    "Add a new hero section to index.html.",
    "Update the color and size of the main call-to-action button in styles/style.css.",
    "Delete the old-logo.svg file as it is no longer used."
  ],
  "file_changes": {
    "index.html": "<!DOCTYPE html>\\n<html>...</html>",
    "styles/style.css": "body {\\n  font-family: sans-serif;\\n}\\n\\n.button {\\n  background-color: #ff6b6b;\\n}",
    "assets/old-logo.svg": null
  }
}
\`\`\`
- The JSON object MUST have three keys: \`message\` (string), \`plan\` (array of strings), and \`file_changes\` (object).
- In \`file_changes\`, the key is the file path and the value is the FULL new content of the file.
- To DELETE a file, the value for that file path MUST be \`null\`.
- Ensure all file content within the JSON is a single-line string with properly escaped characters (e.g., \`\\n\` for newlines, \`\\"\` for quotes).

**Current Project Files:**
${JSON.stringify(project.fileTree, null, 2)}

${isSeniorMode ? 'The user is in Senior Mode. Provide more technical details and code-focused responses. Be concise and direct.' : ''}
`;

            const parts: any[] = [{ text: message.text }];
            if (message.images) {
                message.images.forEach(img => {
                    parts.push({ inlineData: { mimeType: img.mimeType, data: img.data } });
                });
            }

            const model = genAI.getGenerativeModel({
                model: 'gemini-2.5-flash',
                systemInstruction: systemInstruction
            });

            const result = await model.generateContent({
                contents: [{ parts: [{ text: parts.map(p => p.text).join('\n') }] }],
                generationConfig: {
                    maxOutputTokens: 65536, // Maximum output tokens for Gemini 2.5 Flash
                    temperature: 0.1, // Lower temperature for more consistent code generation
                }
            });
            const response = await result.response;
            let text = response.text();

            if (!text) {
                throw new Error(t('editor.errorMissingMessage', language));
            }

            // Log response size for debugging
            console.log(`üìä API response size: ${text.length} characters`);

            // Apply 1MB limit to prevent memory issues
            const MAX_RESPONSE_SIZE = 1048576; // 1MB limit
            if (text.length > MAX_RESPONSE_SIZE) {
                console.warn(`‚ö†Ô∏è Response too large (${text.length} chars), truncating to 1MB`);

                // Try to find the last complete JSON block within the limit
                const truncatedText = text.substring(0, MAX_RESPONSE_SIZE);
                const jsonStart = truncatedText.indexOf('```json');

                if (jsonStart !== -1) {
                    // Look for the last complete JSON block within the limit
                    const lastJsonEnd = truncatedText.lastIndexOf('```');
                    if (lastJsonEnd > jsonStart + 7) {
                        // Check if the content before the last ``` looks like valid JSON end
                        const beforeEnd = truncatedText.substring(lastJsonEnd - 20, lastJsonEnd).trim();
                        if (beforeEnd.includes('}') || beforeEnd.includes(']')) {
                            text = truncatedText.substring(0, lastJsonEnd + 3);
                            console.log(`‚úÇÔ∏è Truncated to complete JSON block (${text.length} chars)`);
                        } else {
                            text = truncatedText;
                            console.log(`‚úÇÔ∏è Truncated to 1MB limit (${text.length} chars)`);
                        }
                    } else {
                        text = truncatedText;
                        console.log(`‚úÇÔ∏è Truncated to 1MB limit (${text.length} chars)`);
                    }
                } else {
                    text = truncatedText;
                    console.log(`‚úÇÔ∏è Truncated to 1MB limit (${text.length} chars)`);
                }
            }

            // Only attempt to fix truncated JSON if the response seems incomplete
            else if (text.length > 100000 && !text.trim().endsWith('```')) {
                console.warn(`‚ö†Ô∏è Large response (${text.length} chars) may be truncated, attempting to find complete JSON`);

                const jsonStart = text.indexOf('```json');
                if (jsonStart !== -1) {
                    // Look for the last complete JSON block
                    const lastJsonEnd = text.lastIndexOf('```');
                    if (lastJsonEnd > jsonStart + 7) {
                        // Check if the content before the last ``` looks like valid JSON end
                        const beforeEnd = text.substring(lastJsonEnd - 20, lastJsonEnd).trim();
                        if (beforeEnd.includes('}') || beforeEnd.includes(']')) {
                            text = text.substring(0, lastJsonEnd + 3);
                            console.log(`‚úÇÔ∏è Used complete JSON block (${text.length} chars)`);
                        }
                    }
                }
            }

            const { text: aiMessage, plan, fileChanges } = parseAndApplyFileChanges(text, isFirstMessage);

            // Auto-enhance project with modern features
            if (fileChanges && fileChanges.length > 0) {
                let enhancedFileTree = { ...project.fileTree };
                let enhancements: string[] = [];

                // 1. Real Data Integration
                const needsData = aiMessage.toLowerCase().includes('data') ||
                    aiMessage.toLowerCase().includes('api') ||
                    aiMessage.toLowerCase().includes('fetch') ||
                    enhancedFileTree['index.html']?.includes('blog') ||
                    enhancedFileTree['index.html']?.includes('portfolio') ||
                    enhancedFileTree['index.html']?.includes('gallery');

                if (needsData && !enhancedFileTree['scripts/data-service.js']) {
                    enhancedFileTree = RealDataIntegrator.injectDataFetching(enhancedFileTree, popularDataSources);
                    enhancements.push('Real data integration');
                }

                // 2. Smart Typography (for new projects or when typography is mentioned)
                const needsTypography = isFirstMessage ||
                    aiMessage.toLowerCase().includes('font') ||
                    aiMessage.toLowerCase().includes('typography') ||
                    aiMessage.toLowerCase().includes('text');

                if (needsTypography && !enhancedFileTree['styles/typography.css']) {
                    const projectType = detectProjectType(message.text, enhancedFileTree);
                    const suggestions = SmartTypographyManager.suggestTypography(message.text, projectType);
                    if (suggestions.length > 0) {
                        enhancedFileTree = SmartTypographyManager.injectTypography(enhancedFileTree, suggestions[0]);
                        enhancements.push('Smart typography');
                    }
                }

                // 3. Dark Mode (for new projects)
                const needsDarkMode = isFirstMessage && !enhancedFileTree['scripts/dark-mode.js'];
                if (needsDarkMode) {
                    enhancedFileTree = DarkModeGenerator.injectDarkMode(enhancedFileTree);
                    enhancements.push('Dark mode support');
                }

                // 4. Animations (when animations are mentioned or for interactive elements)
                const needsAnimations = aiMessage.toLowerCase().includes('animation') ||
                    aiMessage.toLowerCase().includes('hover') ||
                    aiMessage.toLowerCase().includes('transition') ||
                    (isFirstMessage && enhancedFileTree['index.html']?.includes('button'));

                if (needsAnimations && !enhancedFileTree['styles/animations.css']) {
                    const projectType = detectProjectType(message.text, enhancedFileTree);
                    const suggestedAnimations = AnimationLibrary.suggestAnimationsForProject(projectType);
                    enhancedFileTree = AnimationLibrary.injectAnimations(enhancedFileTree, suggestedAnimations);
                    enhancements.push('Modern animations');
                }

                // 5. Gradients (when design/visual improvements are mentioned)
                const needsGradients = aiMessage.toLowerCase().includes('gradient') ||
                    aiMessage.toLowerCase().includes('background') ||
                    aiMessage.toLowerCase().includes('visual') ||
                    (isFirstMessage && aiMessage.toLowerCase().includes('modern'));

                if (needsGradients && !enhancedFileTree['styles/gradients.css']) {
                    const projectType = detectProjectType(message.text, enhancedFileTree);
                    const suggestedGradients = GradientGenerator.suggestGradientsForProject(projectType);
                    enhancedFileTree = GradientGenerator.injectGradients(enhancedFileTree, suggestedGradients);
                    enhancements.push('Modern gradients');
                }

                // 6. Icon Library (when icons are mentioned or for navigation)
                const needsIcons = aiMessage.toLowerCase().includes('icon') ||
                    aiMessage.toLowerCase().includes('navigation') ||
                    (isFirstMessage && enhancedFileTree['index.html']?.includes('nav'));

                if (needsIcons && !enhancedFileTree['docs/icons.md']) {
                    enhancedFileTree = IconLibraryManager.injectIconLibrary(enhancedFileTree, IconLibraryManager.lucideIcons.slice(0, 10));
                    enhancements.push('Icon library');
                }

                // Apply enhancements if any were made
                if (enhancements.length > 0) {
                    updateFileTree(enhancedFileTree, `Enhanced with: ${enhancements.join(', ')}`);
                }
            }

            // Sugerir nome melhor para o projeto se √© a primeira mensagem
            if (isFirstMessage && message.text && fileChanges && fileChanges.length > 0) {
                try {
                    const suggestedName = await ProjectNameGenerator.generateProjectName(message.text);
                    if (suggestedName && suggestedName !== project.name) {
                        setProject(p => ({ ...p, name: suggestedName }));

                        // Adicionar mensagem sobre a atualiza√ß√£o do nome
                        const nameUpdateMessage: Message = {
                            id: `name-update-${Date.now()}`,
                            role: 'assistant',
                            text: t('editor.projectNameUpdated', language, { newName: suggestedName })
                        };
                        setMessages(prev => [...prev, nameUpdateMessage]);
                    }
                } catch (error) {
                    console.warn('Failed to generate better project name:', error);
                }
            }



            const assistantMessage: Message = {
                id: Date.now().toString(),
                role: 'assistant',
                text: aiMessage,
                plan,
                fileChanges,
            };
            setMessages(prev => [...prev, assistantMessage]);

        } catch (error) {
            console.error('Error calling Gemini API:', error);
            const errorMessage: Message = {
                id: 'error-' + Date.now(),
                role: 'assistant',
                text: t('editor.genericError', language),
            };
            setMessages(prev => [...prev, errorMessage]);
        } finally {
            setIsLoading(false);
        }
    };

    const handleSaveAndExit = () => {
        onSaveAndExit(project);
    };

    const handleNewChat = () => {
        setMessages([{
            id: 'new-chat',
            role: 'assistant',
            text: t('editor.newChatMessage', language)
        }]);
    };

    const handleProjectNameChange = (name: string) => {
        setProject(p => ({ ...p, name }));
    };

    const handleSaveVersion = (name: string) => {
        const newVersion: Version = {
            id: `v-${Date.now()}`,
            name: name,
            createdAt: new Date(),
            fileTree: project.fileTree
        };
        setVersionHistory(prev => [newVersion, ...prev]);
        alert(t('editor.versionSaved', language, { versionName: name }));
    };

    const handleVersionRestore = (fileTree: FileTree) => {
        updateFileTree(fileTree, 'Restored version');
        setMessages(prev => [...prev, { id: 'restore', role: 'assistant', text: t('editor.restoreMessage', language) }]);
    };

    const handleSaveFile = (path: string, content: string) => {
        const newFileTree = { ...project.fileTree, [path]: content };
        updateFileTree(newFileTree, `Edited ${path}`);
    };

    const handleDeleteFile = (path: string) => {
        const newFileTree = { ...project.fileTree };
        delete newFileTree[path];
        updateFileTree(newFileTree, `Deleted ${path}`);
    };

    const handleRenameFile = (oldPath: string, newPath: string) => {
        if (project.fileTree[newPath]) {
            alert(t('codeViewer.renameErrorExists', language, { fileName: newPath }));
            return;
        }
        const newFileTree = { ...project.fileTree };
        newFileTree[newPath] = newFileTree[oldPath];
        delete newFileTree[oldPath];
        // This is a simple text replacement for references. A robust solution would involve AST parsing.
        for (const path in newFileTree) {
            if (path !== newPath) {
                newFileTree[path] = newFileTree[path].replace(new RegExp(oldPath, 'g'), newPath);
            }
        }
        updateFileTree(newFileTree, `Renamed ${oldPath} to ${newPath}`);
        setMessages(prev => [...prev, { id: `rename-${Date.now()}`, role: 'assistant', text: t('editor.fileRenamed', language, { oldPath, newPath }) }]);
    };

    const handleApplyOptimization = (fileChanges: Record<string, string>) => {
        const newFileTree = { ...project.fileTree, ...fileChanges };
        updateFileTree(newFileTree, 'Applied AI optimization');
        setMessages(prev => [...prev, {
            id: `optimization-${Date.now()}`,
            role: 'assistant',
            text: 'I\'ve applied the optimization to your project. Check the preview to see the improvements!'
        }]);
        setIsAnalysisPanelOpen(false);
    };

    return (
        <div className="h-screen w-screen flex flex-col md:flex-row font-body bg-brand-bg dark:bg-dark-bg text-slate-800 dark:text-dark-text">
            <div className={`transition-all duration-300 ${isSidebarVisible ? 'h-1/2 md:h-full md:w-[400px] lg:w-[480px]' : 'h-0 md:w-0'} flex-shrink-0 md:h-full`}>
                <div className="w-full h-full overflow-hidden">
                    <ChatSidebar
                        messages={messages}
                        onSendMessage={handleSendMessage}
                        onNewChat={handleNewChat}
                        onSaveAndExit={handleSaveAndExit}
                        isLoading={isLoading}
                        projectName={project.name}
                        onProjectNameChange={handleProjectNameChange}
                        theme={theme}
                        onThemeChange={onThemeChange}
                        versionHistory={versionHistory}
                        onVersionRestore={handleVersionRestore}
                        language={language}
                        onLanguageChange={onLanguageChange}
                        onInitiateGitHubDeploy={() => setIsGitHubModalOpen(true)}
                        onSaveVersion={handleSaveVersion}
                        onUndo={handleUndo}
                        onRedo={handleRedo}
                        canUndo={canUndo}
                        canRedo={canRedo}
                        onOpenAnalysis={() => setIsAnalysisPanelOpen(true)}
                    />
                </div>
            </div>

            <div className="flex-grow h-1/2 md:h-full">
                <PreviewWindow
                    fileTree={project.fileTree}
                    language={language}
                    isSidebarVisibleOnDesktop={isSidebarVisible}
                    onToggleSidebarOnDesktop={() => setIsSidebarVisible(!isSidebarVisible)}
                    onShowCodeViewer={() => setIsCodeViewerOpen(true)}
                    onInitiatePublish={() => setIsPublishModalOpen(true)}
                    isLoading={isLoading}
                />
            </div>

            {isCodeViewerOpen && (
                <CodeViewerModal
                    fileTree={project.fileTree}
                    onClose={() => setIsCodeViewerOpen(false)}
                    language={language}
                    onSaveFile={handleSaveFile}
                    onDeleteFile={handleDeleteFile}
                    onRenameFile={handleRenameFile}
                />
            )}

            {isPublishModalOpen && (
                <PublishModal
                    onClose={() => setIsPublishModalOpen(false)}
                    projectName={project.name}
                    fileTree={project.fileTree}
                    language={language}
                />
            )}

            {isAnalysisPanelOpen && (
                <AnalysisPanel
                    fileTree={project.fileTree}
                    language={language}
                    onApplyOptimization={handleApplyOptimization}
                    onClose={() => setIsAnalysisPanelOpen(false)}
                />
            )}

            {isGitHubModalOpen && (
                <GitHubDeployModal
                    onClose={() => setIsGitHubModalOpen(false)}
                    projectName={project.name}
                    fileTree={project.fileTree}
                    language={language}
                />
            )}


        </div>
    );
};

export default EditorPage;