import { FileTree, Version } from '../types';

export interface ChangeAnalysis {
    type: 'creation' | 'modification' | 'deletion' | 'improvement' | 'bugfix' | 'feature' | 'refactor';
    description: string;
    filesChanged: string[];
    severity: 'minor' | 'major' | 'critical';
}

export class AutoVersioningSystem {
    /**
     * Analisa as mudanças entre duas versões do FileTree
     */
    static analyzeChanges(oldFileTree: FileTree, newFileTree: FileTree, aiMessage?: string): ChangeAnalysis {
        const oldFiles = new Set(Object.keys(oldFileTree));
        const newFiles = new Set(Object.keys(newFileTree));

        // Arquivos adicionados
        const addedFiles = [...newFiles].filter(file => !oldFiles.has(file));

        // Arquivos removidos
        const deletedFiles = [...oldFiles].filter(file => !newFiles.has(file));

        // Arquivos modificados
        const modifiedFiles = [...newFiles].filter(file =>
            oldFiles.has(file) && oldFileTree[file] !== newFileTree[file]
        );

        const allChangedFiles = [...addedFiles, ...deletedFiles, ...modifiedFiles];

        // Determinar tipo de mudança baseado na análise
        let changeType: ChangeAnalysis['type'] = 'modification';
        let description = '';
        let severity: ChangeAnalysis['severity'] = 'minor';

        // Analisar mensagem da IA para contexto
        const aiContext = aiMessage?.toLowerCase() || '';

        // Detectar tipo de mudança
        if (addedFiles.length > 0 && deletedFiles.length === 0 && modifiedFiles.length === 0) {
            changeType = 'creation';
            description = this.generateCreationDescription(addedFiles);
            severity = 'major';
        } else if (deletedFiles.length > 0) {
            changeType = 'deletion';
            description = this.generateDeletionDescription(deletedFiles);
            severity = 'major';
        } else if (this.isBugFix(aiContext, modifiedFiles, oldFileTree, newFileTree)) {
            changeType = 'bugfix';
            description = this.generateBugfixDescription(modifiedFiles, aiContext);
            severity = 'critical';
        } else if (this.isNewFeature(aiContext, addedFiles, modifiedFiles)) {
            changeType = 'feature';
            description = this.generateFeatureDescription(addedFiles, modifiedFiles, aiContext);
            severity = 'major';
        } else if (this.isImprovement(aiContext, modifiedFiles)) {
            changeType = 'improvement';
            description = this.generateImprovementDescription(modifiedFiles, aiContext);
            severity = 'minor';
        } else if (this.isRefactor(aiContext, modifiedFiles)) {
            changeType = 'refactor';
            description = this.generateRefactorDescription(modifiedFiles, aiContext);
            severity = 'minor';
        } else {
            changeType = 'modification';
            description = this.generateModificationDescription(allChangedFiles);
            severity = 'minor';
        }

        return {
            type: changeType,
            description,
            filesChanged: allChangedFiles,
            severity
        };
    }

    /**
     * Gera uma versão automaticamente baseada na análise de mudanças
     */
    static createAutoVersion(
        oldFileTree: FileTree,
        newFileTree: FileTree,
        aiMessage?: string,
        versionCounter?: number
    ): Version {
        const analysis = this.analyzeChanges(oldFileTree, newFileTree, aiMessage);
        const versionNumber = versionCounter || Date.now();

        return {
            id: `auto-v${versionNumber}`,
            name: analysis.description,
            createdAt: new Date(),
            fileTree: newFileTree,
            metadata: {
                changeType: analysis.type,
                severity: analysis.severity,
                filesChanged: analysis.filesChanged,
                isAutoGenerated: true
            }
        };
    }

    /**
     * Determina se deve criar uma nova versão baseado na significância das mudanças
     */
    static shouldCreateVersion(analysis: ChangeAnalysis): boolean {
        // Sempre criar versão para mudanças críticas e maiores
        if (analysis.severity === 'critical' || analysis.severity === 'major') {
            return true;
        }

        // Para mudanças menores, criar versão se houver múltiplos arquivos alterados
        if (analysis.severity === 'minor' && analysis.filesChanged.length > 1) {
            return true;
        }

        // Sempre criar versão para novos recursos e correções
        if (analysis.type === 'feature' || analysis.type === 'bugfix' || analysis.type === 'creation') {
            return true;
        }

        return false;
    }

    // Métodos de detecção de tipo de mudança
    private static isBugFix(aiContext: string, modifiedFiles: string[], oldFileTree: FileTree, newFileTree: FileTree): boolean {
        const bugKeywords = ['fix', 'bug', 'error', 'issue', 'problem', 'correct', 'repair', 'resolve'];
        const ptBugKeywords = ['corrigir', 'erro', 'problema', 'consertar', 'resolver', 'ajustar'];

        const hasBugKeywords = [...bugKeywords, ...ptBugKeywords].some(keyword =>
            aiContext.includes(keyword)
        );

        // Detectar correções comuns no código
        const hasErrorFixes = modifiedFiles.some(file => {
            const oldContent = oldFileTree[file] || '';
            const newContent = newFileTree[file] || '';

            // Detectar correções de sintaxe, imports, etc.
            return (
                oldContent.includes('undefined') && !newContent.includes('undefined') ||
                oldContent.includes('null') && !newContent.includes('null') ||
                newContent.includes('try') && newContent.includes('catch') ||
                newContent.includes('error') && newContent.includes('handle')
            );
        });

        return hasBugKeywords || hasErrorFixes;
    }

    private static isNewFeature(aiContext: string, addedFiles: string[], modifiedFiles: string[]): boolean {
        const featureKeywords = ['add', 'new', 'create', 'implement', 'feature', 'functionality'];
        const ptFeatureKeywords = ['adicionar', 'novo', 'nova', 'criar', 'implementar', 'funcionalidade'];

        const hasFeatureKeywords = [...featureKeywords, ...ptFeatureKeywords].some(keyword =>
            aiContext.includes(keyword)
        );

        // Detectar adição de novos componentes ou funcionalidades
        const hasNewComponents = addedFiles.some(file =>
            file.includes('component') || file.includes('page') || file.includes('feature')
        );

        return hasFeatureKeywords || hasNewComponents || addedFiles.length > 0;
    }

    private static isImprovement(aiContext: string, modifiedFiles: string[]): boolean {
        const improvementKeywords = ['improve', 'enhance', 'optimize', 'better', 'upgrade', 'refine'];
        const ptImprovementKeywords = ['melhorar', 'aprimorar', 'otimizar', 'aperfeiçoar', 'atualizar'];

        return [...improvementKeywords, ...ptImprovementKeywords].some(keyword =>
            aiContext.includes(keyword)
        );
    }

    private static isRefactor(aiContext: string, modifiedFiles: string[]): boolean {
        const refactorKeywords = ['refactor', 'restructure', 'reorganize', 'clean', 'simplify'];
        const ptRefactorKeywords = ['refatorar', 'reestruturar', 'reorganizar', 'limpar', 'simplificar'];

        return [...refactorKeywords, ...ptRefactorKeywords].some(keyword =>
            aiContext.includes(keyword)
        );
    }

    // Métodos de geração de descrição
    private static generateCreationDescription(addedFiles: string[]): string {
        if (addedFiles.length === 1) {
            return `Criado ${addedFiles[0]}`;
        }
        return `Criados ${addedFiles.length} novos arquivos`;
    }

    private static generateDeletionDescription(deletedFiles: string[]): string {
        if (deletedFiles.length === 1) {
            return `Removido ${deletedFiles[0]}`;
        }
        return `Removidos ${deletedFiles.length} arquivos`;
    }

    private static generateBugfixDescription(modifiedFiles: string[], aiContext: string): string {
        if (aiContext.includes('fix') || aiContext.includes('corrigir')) {
            return `Correção de bug em ${modifiedFiles.length} arquivo(s)`;
        }
        return `Correção aplicada`;
    }

    private static generateFeatureDescription(addedFiles: string[], modifiedFiles: string[], aiContext: string): string {
        const totalFiles = addedFiles.length + modifiedFiles.length;

        if (aiContext.includes('component') || aiContext.includes('componente')) {
            return `Novo componente adicionado`;
        }
        if (aiContext.includes('page') || aiContext.includes('página')) {
            return `Nova página criada`;
        }
        if (aiContext.includes('feature') || aiContext.includes('funcionalidade')) {
            return `Nova funcionalidade implementada`;
        }

        return `Novo recurso adicionado (${totalFiles} arquivos)`;
    }

    private static generateImprovementDescription(modifiedFiles: string[], aiContext: string): string {
        if (aiContext.includes('style') || aiContext.includes('design') || aiContext.includes('estilo')) {
            return `Melhorias visuais aplicadas`;
        }
        if (aiContext.includes('performance') || aiContext.includes('speed') || aiContext.includes('otimizar')) {
            return `Otimizações de performance`;
        }
        if (aiContext.includes('accessibility') || aiContext.includes('acessibilidade')) {
            return `Melhorias de acessibilidade`;
        }

        return `Melhorias gerais aplicadas`;
    }

    private static generateRefactorDescription(modifiedFiles: string[], aiContext: string): string {
        return `Refatoração de código (${modifiedFiles.length} arquivos)`;
    }

    private static generateModificationDescription(changedFiles: string[]): string {
        if (changedFiles.length === 1) {
            return `Atualizado ${changedFiles[0]}`;
        }
        return `Atualizados ${changedFiles.length} arquivos`;
    }

    /**
     * Gera um resumo das mudanças para exibição
     */
    static generateChangeSummary(analysis: ChangeAnalysis): string {
        const { type, filesChanged, severity } = analysis;

        const typeEmojis = {
            creation: '✨',
            modification: '📝',
            deletion: '🗑️',
            improvement: '⚡',
            bugfix: '🐛',
            feature: '🚀',
            refactor: '🔧'
        };

        const severityEmojis = {
            minor: '🔵',
            major: '🟡',
            critical: '🔴'
        };

        return `${typeEmojis[type]} ${severityEmojis[severity]} ${analysis.description}`;
    }
}