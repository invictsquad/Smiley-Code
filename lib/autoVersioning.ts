import { FileTree, Version } from '../types';

export interface ChangeAnalysis {
    type: 'creation' | 'modification' | 'deletion' | 'improvement' | 'bugfix' | 'feature' | 'refactor';
    description: string;
    filesChanged: string[];
    severity: 'minor' | 'major' | 'critical';
}

export class AutoVersioningSystem {
    /**
     * Analisa as mudan√ßas entre duas vers√µes do FileTree
     */
    static analyzeChanges(oldFileTree: FileTree, newFileTree: FileTree, aiMessage?: string): ChangeAnalysis {
        const oldFiles = new Set(Object.keys(oldFileTree));
        const newFiles = new Set(Object.keys(newFileTree));

        // Arquivos adicionados
        const addedFiles = [...newFiles].filter(file => !oldFiles.has(file));

        // Arquivos removidos
        const deletedFiles = [...oldFiles].filter(file => !newFiles.has(file));

        // Arquivos modificados
        const modifiedFiles = [...newFiles].filter(file =>
            oldFiles.has(file) && oldFileTree[file] !== newFileTree[file]
        );

        const allChangedFiles = [...addedFiles, ...deletedFiles, ...modifiedFiles];

        // Determinar tipo de mudan√ßa baseado na an√°lise
        let changeType: ChangeAnalysis['type'] = 'modification';
        let description = '';
        let severity: ChangeAnalysis['severity'] = 'minor';

        // Analisar mensagem da IA para contexto
        const aiContext = aiMessage?.toLowerCase() || '';

        // Detectar tipo de mudan√ßa
        if (addedFiles.length > 0 && deletedFiles.length === 0 && modifiedFiles.length === 0) {
            changeType = 'creation';
            description = this.generateCreationDescription(addedFiles);
            severity = 'major';
        } else if (deletedFiles.length > 0) {
            changeType = 'deletion';
            description = this.generateDeletionDescription(deletedFiles);
            severity = 'major';
        } else if (this.isBugFix(aiContext, modifiedFiles, oldFileTree, newFileTree)) {
            changeType = 'bugfix';
            description = this.generateBugfixDescription(modifiedFiles, aiContext);
            severity = 'critical';
        } else if (this.isNewFeature(aiContext, addedFiles, modifiedFiles)) {
            changeType = 'feature';
            description = this.generateFeatureDescription(addedFiles, modifiedFiles, aiContext);
            severity = 'major';
        } else if (this.isImprovement(aiContext, modifiedFiles)) {
            changeType = 'improvement';
            description = this.generateImprovementDescription(modifiedFiles, aiContext);
            severity = 'minor';
        } else if (this.isRefactor(aiContext, modifiedFiles)) {
            changeType = 'refactor';
            description = this.generateRefactorDescription(modifiedFiles, aiContext);
            severity = 'minor';
        } else {
            changeType = 'modification';
            description = this.generateModificationDescription(allChangedFiles);
            severity = 'minor';
        }

        return {
            type: changeType,
            description,
            filesChanged: allChangedFiles,
            severity
        };
    }

    /**
     * Gera uma vers√£o automaticamente baseada na an√°lise de mudan√ßas
     */
    static createAutoVersion(
        oldFileTree: FileTree,
        newFileTree: FileTree,
        aiMessage?: string,
        versionCounter?: number
    ): Version {
        const analysis = this.analyzeChanges(oldFileTree, newFileTree, aiMessage);
        const versionNumber = versionCounter || Date.now();

        return {
            id: `auto-v${versionNumber}`,
            name: analysis.description,
            createdAt: new Date(),
            fileTree: newFileTree,
            metadata: {
                changeType: analysis.type,
                severity: analysis.severity,
                filesChanged: analysis.filesChanged,
                isAutoGenerated: true
            }
        };
    }

    /**
     * Determina se deve criar uma nova vers√£o baseado na signific√¢ncia das mudan√ßas
     */
    static shouldCreateVersion(analysis: ChangeAnalysis): boolean {
        // Sempre criar vers√£o para mudan√ßas cr√≠ticas e maiores
        if (analysis.severity === 'critical' || analysis.severity === 'major') {
            return true;
        }

        // Para mudan√ßas menores, criar vers√£o se houver m√∫ltiplos arquivos alterados
        if (analysis.severity === 'minor' && analysis.filesChanged.length > 1) {
            return true;
        }

        // Sempre criar vers√£o para novos recursos e corre√ß√µes
        if (analysis.type === 'feature' || analysis.type === 'bugfix' || analysis.type === 'creation') {
            return true;
        }

        return false;
    }

    // M√©todos de detec√ß√£o de tipo de mudan√ßa
    private static isBugFix(aiContext: string, modifiedFiles: string[], oldFileTree: FileTree, newFileTree: FileTree): boolean {
        const bugKeywords = ['fix', 'bug', 'error', 'issue', 'problem', 'correct', 'repair', 'resolve'];
        const ptBugKeywords = ['corrigir', 'erro', 'problema', 'consertar', 'resolver', 'ajustar'];

        const hasBugKeywords = [...bugKeywords, ...ptBugKeywords].some(keyword =>
            aiContext.includes(keyword)
        );

        // Detectar corre√ß√µes comuns no c√≥digo
        const hasErrorFixes = modifiedFiles.some(file => {
            const oldContent = oldFileTree[file] || '';
            const newContent = newFileTree[file] || '';

            // Detectar corre√ß√µes de sintaxe, imports, etc.
            return (
                oldContent.includes('undefined') && !newContent.includes('undefined') ||
                oldContent.includes('null') && !newContent.includes('null') ||
                newContent.includes('try') && newContent.includes('catch') ||
                newContent.includes('error') && newContent.includes('handle')
            );
        });

        return hasBugKeywords || hasErrorFixes;
    }

    private static isNewFeature(aiContext: string, addedFiles: string[], modifiedFiles: string[]): boolean {
        const featureKeywords = ['add', 'new', 'create', 'implement', 'feature', 'functionality'];
        const ptFeatureKeywords = ['adicionar', 'novo', 'nova', 'criar', 'implementar', 'funcionalidade'];

        const hasFeatureKeywords = [...featureKeywords, ...ptFeatureKeywords].some(keyword =>
            aiContext.includes(keyword)
        );

        // Detectar adi√ß√£o de novos componentes ou funcionalidades
        const hasNewComponents = addedFiles.some(file =>
            file.includes('component') || file.includes('page') || file.includes('feature')
        );

        return hasFeatureKeywords || hasNewComponents || addedFiles.length > 0;
    }

    private static isImprovement(aiContext: string, modifiedFiles: string[]): boolean {
        const improvementKeywords = ['improve', 'enhance', 'optimize', 'better', 'upgrade', 'refine'];
        const ptImprovementKeywords = ['melhorar', 'aprimorar', 'otimizar', 'aperfei√ßoar', 'atualizar'];

        return [...improvementKeywords, ...ptImprovementKeywords].some(keyword =>
            aiContext.includes(keyword)
        );
    }

    private static isRefactor(aiContext: string, modifiedFiles: string[]): boolean {
        const refactorKeywords = ['refactor', 'restructure', 'reorganize', 'clean', 'simplify'];
        const ptRefactorKeywords = ['refatorar', 'reestruturar', 'reorganizar', 'limpar', 'simplificar'];

        return [...refactorKeywords, ...ptRefactorKeywords].some(keyword =>
            aiContext.includes(keyword)
        );
    }

    // M√©todos de gera√ß√£o de descri√ß√£o
    private static generateCreationDescription(addedFiles: string[]): string {
        if (addedFiles.length === 1) {
            return `Criado ${addedFiles[0]}`;
        }
        return `Criados ${addedFiles.length} novos arquivos`;
    }

    private static generateDeletionDescription(deletedFiles: string[]): string {
        if (deletedFiles.length === 1) {
            return `Removido ${deletedFiles[0]}`;
        }
        return `Removidos ${deletedFiles.length} arquivos`;
    }

    private static generateBugfixDescription(modifiedFiles: string[], aiContext: string): string {
        if (aiContext.includes('fix') || aiContext.includes('corrigir')) {
            return `Corre√ß√£o de bug em ${modifiedFiles.length} arquivo(s)`;
        }
        return `Corre√ß√£o aplicada`;
    }

    private static generateFeatureDescription(addedFiles: string[], modifiedFiles: string[], aiContext: string): string {
        const totalFiles = addedFiles.length + modifiedFiles.length;

        if (aiContext.includes('component') || aiContext.includes('componente')) {
            return `Novo componente adicionado`;
        }
        if (aiContext.includes('page') || aiContext.includes('p√°gina')) {
            return `Nova p√°gina criada`;
        }
        if (aiContext.includes('feature') || aiContext.includes('funcionalidade')) {
            return `Nova funcionalidade implementada`;
        }

        return `Novo recurso adicionado (${totalFiles} arquivos)`;
    }

    private static generateImprovementDescription(modifiedFiles: string[], aiContext: string): string {
        if (aiContext.includes('style') || aiContext.includes('design') || aiContext.includes('estilo')) {
            return `Melhorias visuais aplicadas`;
        }
        if (aiContext.includes('performance') || aiContext.includes('speed') || aiContext.includes('otimizar')) {
            return `Otimiza√ß√µes de performance`;
        }
        if (aiContext.includes('accessibility') || aiContext.includes('acessibilidade')) {
            return `Melhorias de acessibilidade`;
        }

        return `Melhorias gerais aplicadas`;
    }

    private static generateRefactorDescription(modifiedFiles: string[], aiContext: string): string {
        return `Refatora√ß√£o de c√≥digo (${modifiedFiles.length} arquivos)`;
    }

    private static generateModificationDescription(changedFiles: string[]): string {
        if (changedFiles.length === 1) {
            return `Atualizado ${changedFiles[0]}`;
        }
        return `Atualizados ${changedFiles.length} arquivos`;
    }

    /**
     * Gera um resumo das mudan√ßas para exibi√ß√£o
     */
    static generateChangeSummary(analysis: ChangeAnalysis): string {
        const { type, filesChanged, severity } = analysis;

        const typeEmojis = {
            creation: '‚ú®',
            modification: 'üìù',
            deletion: 'üóëÔ∏è',
            improvement: '‚ö°',
            bugfix: 'üêõ',
            feature: 'üöÄ',
            refactor: 'üîß'
        };

        const severityEmojis = {
            minor: 'üîµ',
            major: 'üü°',
            critical: 'üî¥'
        };

        return `${typeEmojis[type]} ${severityEmojis[severity]} ${analysis.description}`;
    }
}